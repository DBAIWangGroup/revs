// Generated by CoffeeScript 1.12.5
(function() {
  var find_b, find_s_index, get_init_q, get_pre_image, is_subset, set_diff, set_intersection, simulation;

  simulation = {};

  window.simulation = simulation;

  simulation.get_coarsest_partition = function(adj_lists, node_set, initial_partition, predicate) {
    var b, d, d11, d12, d2, j, len, pre_b, pre_s_minus_b, q, q_prime, s, s_index, s_minus_b, x;
    q = get_init_q(adj_lists, node_set, initial_partition, predicate);
    x = [node_set];
    while (true) {
      s_index = find_s_index(q, x);
      if (s_index === null) {
        break;
      }
      s = x[s_index];
      b = find_b(q, s);
      s_minus_b = set_diff(s, b);
      x.push(b);
      x.push(s_minus_b);
      x.splice(s_index, 1);
      pre_b = get_pre_image(adj_lists, b, predicate);
      pre_s_minus_b = get_pre_image(adj_lists, s_minus_b, predicate);
      q_prime = [];
      for (j = 0, len = q.length; j < len; j++) {
        d = q[j];
        d11 = set_intersection(set_intersection(d, pre_b), pre_s_minus_b);
        d12 = set_intersection(d, set_diff(pre_b, pre_s_minus_b));
        d2 = set_diff(d, pre_b);
        if (Object.keys(d11).length > 0) {
          q_prime.push(d11);
        }
        if (Object.keys(d12).length > 0) {
          q_prime.push(d12);
        }
        if (Object.keys(d2).length > 0) {
          q_prime.push(d2);
        }
      }
      q = q_prime;
    }
    if (!simulation.is_stable_partition(adj_lists, q, predicate)) {
      console.error('Result is not stable!');
    }
    return q;
  };

  simulation.is_stable_partition = function(adj_lists, partition, predicate) {
    var b, diff_size, j, k, len, len1, pre_s, s;
    for (j = 0, len = partition.length; j < len; j++) {
      s = partition[j];
      pre_s = get_pre_image(adj_lists, s, predicate);
      for (k = 0, len1 = partition.length; k < len1; k++) {
        b = partition[k];
        diff_size = Object.keys(set_diff(b - pre_s)).length;
        if (diff_size !== Object.keys(b).length && diff_size !== 0) {
          return false;
        }
      }
    }
    return true;
  };

  set_diff = function(a, b) {
    var diff, item;
    diff = {};
    for (item in a) {
      if (!(item in b)) {
        diff[item] = true;
      }
    }
    return diff;
  };

  set_intersection = function(a, b) {
    var inter, item;
    inter = {};
    for (item in a) {
      if (item in b) {
        inter[item] = true;
      }
    }
    return inter;
  };

  is_subset = function(a, b) {
    var item;
    for (item in a) {
      if (!(item in b)) {
        return false;
      }
    }
    return true;
  };

  get_init_q = function(adj_lists, node_set, initial_partition, predicate) {
    var d, d1, d2, j, len, pre_u, q;
    q = [];
    pre_u = get_pre_image(adj_lists, node_set, predicate);
    for (j = 0, len = initial_partition.length; j < len; j++) {
      d = initial_partition[j];
      d1 = set_intersection(d, pre_u);
      d2 = set_diff(d, pre_u);
      if (Object.keys(d1).length > 0) {
        q.push(d1);
      }
      if (Object.keys(d2).length > 0) {
        q.push(d2);
      }
    }
    return q;
  };

  get_pre_image = function(adj_lists, nodes, predicate) {
    var edge, j, len, node, pre_b, ref;
    pre_b = {};
    for (node in nodes) {
      ref = adj_lists[node];
      for (j = 0, len = ref.length; j < len; j++) {
        edge = ref[j];
        if (predicate === void 0) {
          pre_b[edge.node] = true;
        } else if (edge.predicate === predicate && !edge.is_outgoing) {
          pre_b[edge.node] = true;
        }
      }
    }
    return pre_b;
  };

  find_s_index = function(q, x) {
    var i, j, k, len, len1, q_block, x_block;
    for (i = j = 0, len = x.length; j < len; i = ++j) {
      x_block = x[i];
      for (k = 0, len1 = q.length; k < len1; k++) {
        q_block = q[k];
        if (is_subset(q_block, x_block) && Object.keys(q_block).length < Object.keys(x_block).length) {
          return i;
        }
      }
    }
    return null;
  };

  find_b = function(q, s) {
    var b_candidates, block, i, j, len, subset_count;
    subset_count = 0;
    b_candidates = [];
    for (i = j = 0, len = q.length; j < len; i = ++j) {
      block = q[i];
      if (is_subset(block, s)) {
        subset_count += 1;
        b_candidates.push(block);
        if (subset_count === 2) {
          if (Object.keys(b_candidates[0]).length <= Object.keys(b_candidates[1]).length) {
            return b_candidates[0];
          } else {
            return b_candidates[1];
          }
        }
      }
    }
  };

}).call(this);

//# sourceMappingURL=simulation.js.map
