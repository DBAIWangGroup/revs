// Generated by CoffeeScript 1.12.5
(function() {
  var build_label_dict, build_node_to_group_dict, compute_sub_hierarchy_view, compute_visual_adj_lists, compute_visual_nodes, core, edge_compare, get_block_label, global, sorted_array_diff, visual_node_compare;

  core = {};

  window.core = core;

  global = {
    next_visual_node_id: 1
  };

  core.triples_to_adj_lists = function(triples) {
    var adj_lists, k, len, o, o_adj_list, p, s, s_adj_list, triple;
    adj_lists = {};
    for (k = 0, len = triples.length; k < len; k++) {
      triple = triples[k];
      s = triple.s;
      p = triple.p;
      o = triple.o;
      s_adj_list = adj_lists[s];
      o_adj_list = adj_lists[o];
      if (s_adj_list === void 0) {
        s_adj_list = [];
        adj_lists[s] = s_adj_list;
      }
      if (o_adj_list === void 0) {
        o_adj_list = [];
        adj_lists[o] = o_adj_list;
      }
      s_adj_list.push({
        predicate: p,
        node: o,
        is_outgoing: true
      });
      o_adj_list.push({
        predicate: p,
        node: s,
        is_outgoing: false
      });
    }
    return adj_lists;
  };

  core.get_predicate_priority = function(triples) {
    var count, counts, k, len, predicate, priority, triple;
    counts = {};
    for (k = 0, len = triples.length; k < len; k++) {
      triple = triples[k];
      count = counts[triple.p] || 0;
      counts[triple.p] = count + 1;
    }
    priority = [];
    for (predicate in counts) {
      count = counts[predicate];
      priority.push({
        predicate: predicate,
        score: count
      });
    }
    priority.sort(function(a, b) {
      return b.score - a.score;
    });
    return priority;
  };

  core.get_node_set = function(triples) {
    var k, len, nodes, triple;
    nodes = {};
    for (k = 0, len = triples.length; k < len; k++) {
      triple = triples[k];
      nodes[triple.s] = true;
      nodes[triple.o] = true;
    }
    return nodes;
  };

  core.get_clean_type_dict = function(type_dict, node_set) {
    var node, type_dict_copy, types;
    type_dict_copy = {};
    for (node in type_dict) {
      types = type_dict[node];
      if (node in node_set) {
        type_dict_copy[node] = types;
      }
    }
    return type_dict_copy;
  };

  core.get_init_partition = function(nodes, source, target, type_dict, type_info) {
    var block, block_assigned, k, l, len, len1, node, node_types, other_nodes, others_block, partition, target_block, type, type_blocks;
    partition = [];
    other_nodes = [];
    for (node in nodes) {
      if (node !== source && node !== target) {
        other_nodes.push(node);
      } else {
        block = {};
        block[node] = true;
        partition.push(block);
      }
    }
    type_blocks = {};
    others_block = {};
    for (k = 0, len = other_nodes.length; k < len; k++) {
      node = other_nodes[k];
      node_types = type_dict[node];
      block_assigned = false;
      for (l = 0, len1 = node_types.length; l < len1; l++) {
        type = node_types[l];
        if (type_info.types[type].active) {
          target_block = type_blocks[type];
          if (target_block === void 0) {
            target_block = {};
            type_blocks[type] = target_block;
            partition.push(target_block);
          }
          target_block[node] = true;
          block_assigned = true;
          break;
        }
      }
      if (!block_assigned) {
        others_block[node] = true;
      }
    }
    if (Object.keys(others_block).length > 0) {
      partition.push(others_block);
    }
    return partition;
  };

  core.get_type_info = function(type_dict) {
    var child_type, info, k, len, node, node_types, root_info, type, type_info;
    type_info = {
      root: void 0,
      types: {}
    };
    for (node in type_dict) {
      node_types = type_dict[node];
      if (type_info.root === void 0) {
        type_info.root = node_types[node_types.length - 1];
      }
      child_type = void 0;
      for (k = 0, len = node_types.length; k < len; k++) {
        type = node_types[k];
        info = type_info.types[type];
        if (info === void 0) {
          info = {
            count: 0,
            children: {}
          };
          type_info.types[type] = info;
        }
        if (child_type !== void 0) {
          info.children[child_type] = true;
        }
        info.count += 1;
        child_type = type;
      }
    }
    root_info = type_info.types[type_info.root];
    root_info.active = true;
    root_info.locked = true;
    return type_info;
  };

  core.compute_type_hierarchy_view = function(type_info) {
    var root_id, root_info, visual_items;
    visual_items = [];
    root_id = type_info.root;
    root_info = type_info.types[root_id];
    visual_items.push({
      id: root_id,
      depth: 0,
      data: root_info
    });
    compute_sub_hierarchy_view(root_info.children, type_info, 1, visual_items);
    return visual_items;
  };

  compute_sub_hierarchy_view = function(children, type_info, depth, visual_items) {
    var info, results, type;
    results = [];
    for (type in children) {
      info = type_info.types[type];
      visual_items.push({
        id: type,
        depth: depth,
        data: info
      });
      results.push(compute_sub_hierarchy_view(info.children, type_info, depth + 1, visual_items));
    }
    return results;
  };

  core.random_refinement = function(partition) {
    var block, block_a_nodes, block_b_nodes, candidate_blocks, i, k, len, new_block_a, new_block_b, node, size_a, size_b, target_block, transfer_node;
    candidate_blocks = [];
    for (i = k = 0, len = partition.length; k < len; i = ++k) {
      block = partition[i];
      if (Object.keys(block).length === 1) {
        continue;
      }
      candidate_blocks.push({
        index: i,
        block: block
      });
    }
    if (candidate_blocks.length === 0) {
      return;
    }
    target_block = candidate_blocks[Math.floor(Math.random() * candidate_blocks.length)];
    new_block_a = {};
    new_block_b = {};
    size_a = 0;
    size_b = 0;
    for (node in target_block.block) {
      if (Math.random() > 0.5) {
        new_block_a[node] = true;
        ++size_a;
      } else {
        new_block_b[node] = true;
        ++size_b;
      }
    }
    if (size_a === 0) {
      block_b_nodes = Object.keys(new_block_b);
      transfer_node = block_b_nodes[Math.floor(Math.random() * block_b_nodes.length)];
      new_block_a[transfer_node] = true;
      delete new_block_b[transfer_node];
    }
    if (size_b === 0) {
      block_a_nodes = Object.keys(new_block_a);
      transfer_node = block_a_nodes[Math.floor(Math.random() * block_a_nodes.length)];
      new_block_b[transfer_node] = true;
      delete new_block_a[transfer_node];
    }
    return partition.splice(target_block.index, 1, new_block_a, new_block_b);
  };

  core.random_generalisation = function(partition, source, target) {
    var block, candidate_blocks, i, k, len, new_block, node, target_block_a, target_block_a_index, target_block_b;
    candidate_blocks = [];
    for (i = k = 0, len = partition.length; k < len; i = ++k) {
      block = partition[i];
      if (block[source] || block[target]) {
        continue;
      }
      candidate_blocks.push({
        index: i,
        block: block
      });
    }
    if (candidate_blocks.length < 2) {
      return;
    }
    target_block_a_index = Math.floor(Math.random() * candidate_blocks.length);
    target_block_a = candidate_blocks[target_block_a_index];
    candidate_blocks.splice(target_block_a_index, 1);
    target_block_b = candidate_blocks[Math.floor(Math.random() * candidate_blocks.length)];
    new_block = {};
    for (node in target_block_a.block) {
      new_block[node] = true;
    }
    for (node in target_block_b.block) {
      new_block[node] = true;
    }
    if (target_block_a.index > target_block_b.index) {
      partition.splice(target_block_a.index, 1);
      partition.splice(target_block_b.index, 1);
    } else {
      partition.splice(target_block_b.index, 1);
      partition.splice(target_block_a.index, 1);
    }
    return partition.push(new_block);
  };

  core.compute_view_model = function(adj_lists, type_dict, partition, old_model) {
    var added_edge, added_node, adj_list, diff, edge, edge_diff, k, kept_id, kept_node, l, len, len1, len2, len3, len4, len5, len6, len7, len8, model, old_adj_list, old_visual_nodes, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, removed_edge, removed_node, t, u, v, visual_adj_lists, visual_node, visual_node_label_dict, visual_nodes, w, x;
    old_visual_nodes = old_model !== void 0 ? old_model.nodes : void 0;
    visual_nodes = compute_visual_nodes(partition, type_dict, old_visual_nodes);
    visual_node_label_dict = build_label_dict(visual_nodes);
    visual_adj_lists = compute_visual_adj_lists(adj_lists, visual_nodes);
    model = {
      nodes: visual_nodes,
      label_dict: visual_node_label_dict,
      adj_lists: visual_adj_lists,
      nodes_added: [],
      nodes_removed: [],
      edges_added: [],
      edges_removed: []
    };
    if (old_model === void 0) {
      model.nodes_added = visual_nodes;
      for (k = 0, len = visual_nodes.length; k < len; k++) {
        visual_node = visual_nodes[k];
        ref = visual_adj_lists[visual_node.id];
        for (l = 0, len1 = ref.length; l < len1; l++) {
          edge = ref[l];
          if (edge.is_outgoing) {
            model.edges_added.push({
              source: visual_node.id,
              target: edge.node,
              predicate: edge.predicate
            });
          }
        }
      }
    } else {
      diff = sorted_array_diff(old_model.nodes, visual_nodes, visual_node_compare);
      model.nodes_added = diff.added;
      model.nodes_removed = diff.removed;
      ref1 = model.nodes_added;
      for (q = 0, len2 = ref1.length; q < len2; q++) {
        added_node = ref1[q];
        ref2 = visual_adj_lists[added_node.id];
        for (r = 0, len3 = ref2.length; r < len3; r++) {
          edge = ref2[r];
          if (edge.is_outgoing) {
            model.edges_added.push({
              source: added_node.id,
              target: edge.node,
              predicate: edge.predicate
            });
          }
        }
      }
      ref3 = model.nodes_removed;
      for (t = 0, len4 = ref3.length; t < len4; t++) {
        removed_node = ref3[t];
        ref4 = old_model.adj_lists[removed_node.id];
        for (u = 0, len5 = ref4.length; u < len5; u++) {
          edge = ref4[u];
          if (edge.is_outgoing) {
            model.edges_removed.push({
              source: removed_node.id,
              target: edge.node,
              predicate: edge.predicate
            });
          }
        }
      }
      ref5 = diff.kept;
      for (v = 0, len6 = ref5.length; v < len6; v++) {
        kept_node = ref5[v];
        kept_id = kept_node.id;
        old_adj_list = old_model.adj_lists[kept_id];
        adj_list = visual_adj_lists[kept_id];
        edge_diff = sorted_array_diff(old_adj_list, adj_list, edge_compare);
        ref6 = edge_diff.added;
        for (w = 0, len7 = ref6.length; w < len7; w++) {
          added_edge = ref6[w];
          if (added_edge.is_outgoing) {
            model.edges_added.push({
              source: kept_id,
              target: added_edge.node,
              predicate: added_edge.predicate
            });
          }
        }
        ref7 = edge_diff.removed;
        for (x = 0, len8 = ref7.length; x < len8; x++) {
          removed_edge = ref7[x];
          if (removed_edge.is_outgoing) {
            model.edges_removed.push({
              source: kept_id,
              target: removed_edge.node,
              predicate: removed_edge.predicate
            });
          }
        }
      }
    }
    model.nodes_to_group = build_node_to_group_dict(model.nodes);
    return model;
  };

  build_node_to_group_dict = function(visual_nodes) {
    var k, l, len, len1, node, nodes_to_group, ref, visual_node;
    nodes_to_group = {};
    for (k = 0, len = visual_nodes.length; k < len; k++) {
      visual_node = visual_nodes[k];
      ref = visual_node.nodes;
      for (l = 0, len1 = ref.length; l < len1; l++) {
        node = ref[l];
        nodes_to_group[node] = visual_node.id;
      }
    }
    return nodes_to_group;
  };

  build_label_dict = function(visual_nodes) {
    var dict, k, len, node;
    dict = {};
    for (k = 0, len = visual_nodes.length; k < len; k++) {
      node = visual_nodes[k];
      dict[node.id] = node.label;
    }
    return dict;
  };

  visual_node_compare = function(a, b) {
    return a.id.localeCompare(b.id);
  };

  edge_compare = function(a, b) {
    var cmp;
    cmp = a.predicate.localeCompare(b.predicate);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = a.node.localeCompare(b.node);
    if (cmp !== 0) {
      return cmp;
    }
    if (a.is_outgoing) {
      if (b.is_outgoing) {
        return 0;
      } else {
        return 1;
      }
    } else {
      if (b.is_outgoing) {
        return -1;
      } else {
        return 0;
      }
    }
  };

  sorted_array_diff = function(a, b, compare_func) {
    var cmp, ele_a, ele_b, i, j, m, n, result;
    result = {
      added: [],
      removed: [],
      kept: []
    };
    i = 0;
    j = 0;
    m = a.length;
    n = b.length;
    while (i < m && j < n) {
      ele_a = a[i];
      ele_b = b[j];
      cmp = compare_func(ele_a, ele_b);
      if (cmp === 0) {
        result.kept.push(ele_a);
        ++i;
        ++j;
      } else if (cmp < 0) {
        result.removed.push(ele_a);
        ++i;
      } else {
        result.added.push(ele_b);
        ++j;
      }
    }
    while (i < m) {
      ele_a = a[i];
      result.removed.push(ele_a);
      ++i;
    }
    while (j < n) {
      ele_b = b[j];
      result.added.push(ele_b);
      ++j;
    }
    return result;
  };

  compute_visual_adj_lists = function(adj_lists, visual_nodes) {
    var adj_list, edge, existing_visual_edge, is_new_visual_edge, k, l, len, len1, len2, len3, node, node_to_visual_node_dict, q, r, ref, visual_adj_list, visual_adj_lists, visual_edge, visual_node;
    visual_adj_lists = {};
    node_to_visual_node_dict = {};
    for (k = 0, len = visual_nodes.length; k < len; k++) {
      visual_node = visual_nodes[k];
      visual_adj_lists[visual_node.id] = [];
      ref = visual_node.nodes;
      for (l = 0, len1 = ref.length; l < len1; l++) {
        node = ref[l];
        node_to_visual_node_dict[node] = visual_node;
      }
    }
    for (node in adj_lists) {
      adj_list = adj_lists[node];
      visual_adj_list = visual_adj_lists[node_to_visual_node_dict[node].id];
      for (q = 0, len2 = adj_list.length; q < len2; q++) {
        edge = adj_list[q];
        visual_edge = {
          predicate: edge.predicate,
          node: node_to_visual_node_dict[edge.node].id,
          is_outgoing: edge.is_outgoing
        };
        is_new_visual_edge = true;
        for (r = 0, len3 = visual_adj_list.length; r < len3; r++) {
          existing_visual_edge = visual_adj_list[r];
          if (edge_compare(visual_edge, existing_visual_edge) === 0) {
            is_new_visual_edge = false;
            break;
          }
        }
        if (is_new_visual_edge) {
          visual_adj_list.push(visual_edge);
        }
      }
    }
    for (node in visual_adj_lists) {
      adj_list = visual_adj_lists[node];
      adj_list.sort(edge_compare);
    }
    return visual_adj_lists;
  };

  compute_visual_nodes = function(partition, type_dict, old_visual_nodes) {
    var i, j, k, l, len, len1, len2, len3, match_found, match_node_index, matched_old_visual_node, node_set, nodes, old_node, old_visual_node, old_visual_nodes_to_compare, q, r, ref, visual_nodes;
    old_visual_nodes_to_compare = void 0;
    if (old_visual_nodes !== void 0) {
      old_visual_nodes_to_compare = [];
      for (k = 0, len = old_visual_nodes.length; k < len; k++) {
        old_visual_node = old_visual_nodes[k];
        old_visual_nodes_to_compare.push(old_visual_node);
      }
    }
    visual_nodes = [];
    for (l = 0, len1 = partition.length; l < len1; l++) {
      node_set = partition[l];
      nodes = Object.keys(node_set);
      if (nodes.length === 1) {
        visual_nodes.push({
          id: nodes[0],
          label: nodes[0],
          nodes: nodes
        });
      } else {
        nodes.sort();
        matched_old_visual_node = void 0;
        if (old_visual_nodes_to_compare !== void 0) {
          match_found = false;
          match_node_index = void 0;
          for (i = q = 0, len2 = old_visual_nodes_to_compare.length; q < len2; i = ++q) {
            old_visual_node = old_visual_nodes_to_compare[i];
            if (old_visual_node.nodes.length !== nodes.length) {
              continue;
            }
            match_found = true;
            ref = old_visual_node.nodes;
            for (j = r = 0, len3 = ref.length; r < len3; j = ++r) {
              old_node = ref[j];
              if (nodes[j] !== old_node) {
                match_found = false;
                break;
              }
            }
            if (match_found) {
              matched_old_visual_node = old_visual_node;
              match_node_index = i;
              break;
            }
          }
          if (match_found) {
            old_visual_nodes_to_compare.splice(match_node_index, 1);
          }
        }
        if (matched_old_visual_node === void 0) {
          visual_nodes.push({
            id: '?v' + (global.next_visual_node_id++),
            label: get_block_label(nodes, type_dict),
            nodes: nodes
          });
        } else {
          visual_nodes.push({
            id: matched_old_visual_node.id,
            label: matched_old_visual_node.label,
            nodes: nodes
          });
        }
      }
    }
    return visual_nodes.sort(visual_node_compare);
  };

  get_block_label = function(nodes, type_dict) {
    var item, k, label, len, node, node_type, sorted_types, top_type_names, top_types, type, type_summary;
    type_summary = {};
    for (k = 0, len = nodes.length; k < len; k++) {
      node = nodes[k];
      node_type = type_dict[node][0];
      if (!(node_type in type_summary)) {
        type_summary[node_type] = 1;
      } else {
        type_summary[node_type] += 1;
      }
    }
    sorted_types = ((function() {
      var results;
      results = [];
      for (type in type_summary) {
        results.push({
          "type": type,
          "count": type_summary[type]
        });
      }
      return results;
    })()).sort(function(a, b) {
      return b['count'] - a['count'];
    });
    top_types = sorted_types.slice(0, 3);
    top_type_names = (function() {
      var l, len1, results;
      results = [];
      for (l = 0, len1 = top_types.length; l < len1; l++) {
        item = top_types[l];
        results.push(item['type']);
      }
      return results;
    })();
    label = top_type_names.join('/');
    if (sorted_types.length > 3) {
      label += '/…';
    }
    return label;
  };

}).call(this);

//# sourceMappingURL=core.js.map
